<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV Validator & Processor</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');
        
        :root {
            --primary-color: #6366f1;
            --primary-dark: #4f46e5;
            --primary-light: #818cf8;
            --secondary-color: #3b82f6;
            --secondary-dark: #2563eb;
            --error-color: #ef4444;
            --error-light: #fca5a5;
            --warning-color: #f59e0b;
            --warning-light: #fbbf24;
            --success-color: #10b981;
            --success-light: #34d399;
            --background-color: #f0f2f5;
            --card-bg: #ffffff;
            --border-color: #e5e7eb;
            --text-color: #1f2937;
            --text-light: #6b7280;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #e9ecef 100%);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            line-height: 1.6;
            min-height: 100vh;
            background-attachment: fixed;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 100vh;
            background: 
                radial-gradient(circle at 20% 50%, rgba(99, 102, 241, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(59, 130, 246, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 40% 20%, rgba(16, 185, 129, 0.05) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        header {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-dark) 100%);
            color: white;
            padding: 40px 30px;
            border-radius: 16px;
            margin-bottom: 30px;
            box-shadow: var(--shadow-xl);
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -10%;
            width: 60%;
            height: 200%;
            background: rgba(255, 255, 255, 0.05);
            transform: rotate(35deg);
        }

        h1 {
            margin: 0;
            font-size: 32px;
            font-weight: 700;
            letter-spacing: -0.5px;
            position: relative;
            z-index: 1;
        }

        header p {
            margin: 8px 0 0 0;
            opacity: 0.9;
            font-size: 16px;
            position: relative;
            z-index: 1;
        }

        .card {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 24px;
            box-shadow: var(--shadow);
            transition: all 0.3s ease;
            position: relative;
        }

        .card:hover {
            box-shadow: var(--shadow-xl);
            transform: translateY(-2px);
        }

        h2 {
            font-size: 24px;
            font-weight: 700;
            margin: 0 0 20px 0;
            color: var(--text-color);
            letter-spacing: -0.5px;
        }

        h3 {
            font-size: 20px;
            font-weight: 600;
            margin: 0 0 16px 0;
            color: var(--text-color);
        }

        /* Upload Section */
        .upload-section {
            text-align: center;
            padding: 60px 40px;
            border: 2px dashed var(--border-color);
            border-radius: 16px;
            background: linear-gradient(135deg, #f8f9ff 0%, #ffffff 100%);
            transition: all 0.3s ease;
        }

        .upload-section::before {
            content: '☁️';
            font-size: 48px;
            display: block;
            margin-bottom: 20px;
        }

        .upload-section.dragover {
            border-color: var(--primary-color);
            background: linear-gradient(135deg, #e0e7ff 0%, #f0f4ff 100%);
            transform: scale(1.02);
        }

        .upload-section h2 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .upload-section p {
            color: var(--text-light);
            margin-bottom: 24px;
            font-size: 16px;
        }

        .file-input {
            display: none;
        }

        .upload-button {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-dark) 100%);
            color: white;
            padding: 14px 36px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.2);
            letter-spacing: 0.5px;
        }

        .upload-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.3);
        }

        .upload-button:active {
            transform: translateY(0);
        }

        /* Parameters Section */
        .parameters-section {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 24px;
            margin-top: 24px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group label {
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-color);
            font-size: 14px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .form-group input,
        .form-group select {
            padding: 12px 16px;
            border: 2px solid var(--border-color);
            border-radius: 10px;
            font-size: 15px;
            font-family: inherit;
            transition: all 0.2s ease;
            background-color: #f9fafb;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--primary-color);
            background-color: white;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .button-group {
            margin-top: 30px;
            margin-bottom: 30px;
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 28px;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            letter-spacing: 0.3px;
            box-shadow: var(--shadow-sm);
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: var(--shadow-sm);
        }

        .btn:disabled:hover {
            transform: none !important;
            box-shadow: var(--shadow-sm);
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-dark) 100%);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, var(--primary-dark) 0%, #4338ca 100%);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #9ca3af 0%, #6b7280 100%);
            color: white;
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--error-color) 0%, #dc2626 100%);
            color: white;
        }

        .btn-danger:hover {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success-color) 0%, #059669 100%);
            color: white;
        }

        .btn-success:hover {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
        }

        .btn-icon {
            margin-right: 8px;
            font-size: 16px;
        }

        /* Action Buttons Container */
        .action-buttons-container {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin: 30px 0;
            padding: 20px;
            background: linear-gradient(135deg, #f8f9ff 0%, #ffffff 100%);
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .button-row {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
            align-items: center;
        }

        .button-row::before {
            content: '';
            width: 100%;
            height: 0;
            order: -1;
        }

        .primary-actions {
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 16px;
        }

        .download-actions {
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 16px;
        }

        .secondary-actions {
            padding-bottom: 0;
        }

        .btn-highlight {
            position: relative;
            overflow: hidden;
        }

        .btn-highlight::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.3) 0%, transparent 70%);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% {
                transform: translate(-100%, -100%);
            }
            100% {
                transform: translate(100%, 100%);
            }
        }

        .btn-large {
            padding: 16px 40px;
            font-size: 18px;
            font-weight: 700;
            min-width: 280px;
        }

        .btn-large .btn-icon {
            font-size: 20px;
        }

        /* Loading Indicator */
        .loading {
            display: none;
            text-align: center;
            padding: 60px;
            background: linear-gradient(135deg, #f8f9ff 0%, #ffffff 100%);
        }

        .spinner {
            border: 4px solid rgba(99, 102, 241, 0.1);
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 0 auto 24px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Error Display Section */
        .error-section {
            display: none;
        }

        .summary-box {
            background: linear-gradient(135deg, #fef3c7 0%, #fef9e7 100%);
            border: 2px solid #fbbf24;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 24px;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        .summary-item {
            background: white;
            border-radius: 10px;
            padding: 16px 20px;
            box-shadow: var(--shadow-sm);
            transition: all 0.2s ease;
            border-left: 4px solid var(--primary-color);
        }

        .summary-item:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }

        .summary-item.error {
            border-left-color: var(--error-color);
        }

        .summary-item label {
            font-size: 13px;
            color: var(--text-light);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: block;
            margin-bottom: 4px;
        }

        .summary-item span {
            font-size: 28px;
            font-weight: 700;
            display: block;
            color: var(--text-color);
        }

        .category {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            margin-bottom: 16px;
            box-shadow: var(--shadow-sm);
            overflow: hidden;
            transition: all 0.2s ease;
        }

        .category:hover {
            box-shadow: var(--shadow);
        }

        .category-header {
            background: linear-gradient(135deg, var(--secondary-color) 0%, var(--secondary-dark) 100%);
            color: white;
            padding: 16px 24px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            transition: all 0.2s ease;
        }

        .category-header:hover {
            background: linear-gradient(135deg, var(--secondary-dark) 0%, #1d4ed8 100%);
        }

        .category-name {
            font-weight: 600;
            font-size: 18px;
            letter-spacing: -0.3px;
        }

        .category-count {
            background: white;
            color: var(--secondary-color);
            border-radius: 20px;
            padding: 4px 12px;
            font-size: 14px;
            font-weight: 700;
        }

        .category-content {
            display: none;
            padding: 24px;
            background: #f9fafb;
        }

        .reason-group {
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            margin: 16px 0;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }

        .reason-header {
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            padding: 14px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            transition: all 0.2s ease;
        }

        .reason-header:hover {
            background: linear-gradient(135deg, #e5e7eb 0%, #d1d5db 100%);
        }

        .reason-name {
            font-weight: 600;
            font-size: 16px;
            color: var(--text-color);
        }

        .reason-count {
            background: var(--primary-color);
            color: white;
            border-radius: 20px;
            padding: 2px 10px;
            font-size: 12px;
            font-weight: 700;
        }

        .reason-content {
            display: none;
            padding: 20px;
            background: #fafbfc;
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 8px;
            background-color: rgba(99, 102, 241, 0.1);
            border-radius: 999px;
            overflow: hidden;
            margin: 24px 0;
            display: none;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color) 0%, var(--primary-light) 100%);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 999px;
        }

        /* Success Section */
        .success-section {
            display: none;
            text-align: center;
            padding: 60px;
            background: linear-gradient(135deg, #d1fae5 0%, #ecfdf5 100%);
            border: 2px solid var(--success-light);
        }

        .success-icon {
            font-size: 72px;
            color: var(--success-color);
            margin-bottom: 24px;
            animation: successPulse 1s ease;
        }

        @keyframes successPulse {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Alerts */
        .alert {
            padding: 16px 20px;
            margin-bottom: 24px;
            border-radius: 10px;
            display: none;
            animation: slideIn 0.3s ease;
            font-weight: 500;
        }

        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .alert-error {
            background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
            color: #991b1b;
            border: 1px solid var(--error-light);
        }

        .alert-success {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            color: #065f46;
            border: 1px solid var(--success-light);
        }

        .alert-info {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            color: #1e40af;
            border: 1px solid #93c5fd;
        }

        /* Enhanced Tables - Compact Design */
        .data-table, .error-row-table, .sequence-table {
            width: 100%;
            max-width: 1600px;
            border-collapse: collapse;
            margin: 16px auto;
            background: white;
            box-shadow: var(--shadow);
            border-radius: 10px;
            overflow: hidden;
        }

        .data-table th, .error-row-table th, .sequence-table th {
            background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%);
            padding: 8px 10px;
            text-align: left;
            font-weight: 600;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-light);
            border-bottom: 2px solid var(--border-color);
        }

        .data-table td, .error-row-table td, .sequence-table td {
            padding: 6px 10px;
            font-size: 12px;
            border-bottom: 1px solid var(--border-color);
            position: relative;
        }

        /* Row dividers - default for all rows */
        .data-table tr td, .error-row-table tr td, .sequence-table tr td {
            border-bottom: 1px solid var(--border-color);
        }

        /* Remove dividers within sequence groups */
        .data-table tr.sequence-error-row + tr.sequence-error-row td,
        .error-row-table tr.sequence-error-row + tr.sequence-error-row td,
        .sequence-table tr.sequence-error-row + tr.sequence-error-row td {
            border-bottom: none;
        }

        /* For browsers that support :has() - keep divider for last row in sequence group */
        @supports selector(:has(*)) {
            .data-table tr.sequence-error-row:not(:has(+ tr.sequence-error-row)) td,
            .error-row-table tr.sequence-error-row:not(:has(+ tr.sequence-error-row)) td,
            .sequence-table tr.sequence-error-row:not(:has(+ tr.sequence-error-row)) td {
                border-bottom: 1px solid var(--border-color) !important;
            }
        }

        /* Fallback class for last row in sequence - to be added by JavaScript */
        .data-table tr.sequence-error-row.last-in-sequence td,
        .error-row-table tr.sequence-error-row.last-in-sequence td,
        .sequence-table tr.sequence-error-row.last-in-sequence td {
            border-bottom: 1px solid var(--border-color) !important;
        }

        .data-table tr:last-child td, .error-row-table tr:last-child td, .sequence-table tr:last-child td {
            border-bottom: none;
        }

        .data-table tr:hover, .error-row-table tr:hover, .sequence-table tr:hover {
            background-color: #f9fafb;
        }

        .data-table td.error-column, .error-row-table td.error-column {
            background: #ffe5e5 !important;
            border-left: 3px solid var(--warning-color);
            padding: 0;
            color: #111 !important;
            font-weight: bold !important;
        }

        .data-table tr.sequence-error-row {
            background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%) !important;
        }

        .data-table tr.sequence-error-row td, .sequence-table tr.sequence-error-row td {
            background: transparent;
        }

        /* Error and Details cell styling */
        .data-table td:has(> .error-details-box),
        .error-row-table td:has(> .error-details-box),
        .sequence-table td:has(> .error-details-box) {
            padding: 4px;
        }

        .error-details-box {
            border: 2px solid var(--error-color);
            border-radius: 6px;
            background: linear-gradient(135deg, #fee2e2 0%, #fef2f2 100%);
            padding: 6px 10px;
            display: inline-block;
            width: 100%;
            box-sizing: border-box;
        }

        .error-details-box strong {
            color: var(--error-color);
            font-weight: 600;
        }

        /* Apply error box styling to cells containing "Error:" or "Details:" */
        .data-table td:contains("Error:"),
        .data-table td:contains("Details:"),
        .error-row-table td:contains("Error:"),
        .error-row-table td:contains("Details:"),
        .sequence-table td:contains("Error:"),
        .sequence-table td:contains("Details:") {
            padding: 4px !important;
        }
        
        /* Since :contains is not CSS standard, we'll use a class approach */
        .error-info-cell {
            padding: 4px !important;
        }
        
        .error-info-cell > span {
            display: block;
            border: 2px solid var(--error-color);
            border-radius: 6px;
            background: linear-gradient(135deg, #fee2e2 0%, #fef2f2 100%);
            padding: 6px 10px;
            font-size: 12px;
        }

        .editable-input {
            width: 100%;
            padding: 4px 8px;
            border: 2px solid var(--warning-color);
            border-radius: 4px;
            background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
            font-size: 12px;
            font-family: inherit;
            transition: all 0.2s ease;
            font-weight: bold;
        }

        .editable-input:focus {
            outline: none;
            border-color: var(--primary-color);
            background: white;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .data-table .editable-input {
            width: 100%;
            height: 100%;
            padding: 4px 8px;
            border: none;
            background-color: transparent;
            font-size: 12px;
        }

        .data-table .editable-input:focus {
            background-color: white;
            outline: 2px solid var(--secondary-color);
        }

        /* Sequence Error Styles */
        .sequence-summary {
            margin-top: 16px;
            padding: 20px;
            background: linear-gradient(135deg, #fef3c7 0%, #fef9e7 100%);
            border: 2px solid var(--warning-light);
            border-radius: 10px;
            border-left: 5px solid var(--error-color);
        }

        .sequence-summary h4 {
            margin: 0 0 12px 0;
            color: var(--error-color);
            font-size: 18px;
            font-weight: 600;
        }

        .sequence-summary-item {
            margin-bottom: 10px;
            padding: 12px;
            background: white;
            border-radius: 6px;
            font-size: 14px;
            box-shadow: var(--shadow-sm);
        }

        .sequence-table-container {
            margin-bottom: 24px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: var(--shadow);
        }

        .sequence-table-header {
            background: linear-gradient(135deg, var(--error-color) 0%, #dc2626 100%);
            color: white;
            padding: 16px 20px;
            font-weight: 600;
            font-size: 16px;
            letter-spacing: 0.3px;
        }

        /* File Info Styling */
        #fileInfo {
            margin-top: 24px;
            color: var(--text-light);
            font-weight: 500;
        }

        /* Loading Message */
        #loadingMessage {
            color: var(--primary-color);
            margin-bottom: 16px;
            font-weight: 600;
        }

        .red-highlight, .sequence-table tr .red-highlight {
            background: #ffe5e5 !important;
            border-left: 3px solid var(--warning-color);
            padding: 0;
            font-weight: bold !important;
        }

        .sequence-table th, .sequence-table td, .data-table th, .data-table td, .error-row-table th, .error-row-table td {
            text-align: center;
        }

        .data-table, .sequence-table {
            overflow-x: auto;
            display: block;
            max-width: 100%;
        }

        /* Download button styles */
        .download-csv-btn {
            background-color: var(--success-color);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-left: 8px;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            min-width: 60px;
            justify-content: center;
        }

        .download-csv-btn:hover {
            background-color: #059669;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(16, 185, 129, 0.2);
        }

        .download-csv-btn svg {
            width: 14px;
            height: 14px;
        }

        .category-header .download-csv-btn {
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .category-header .download-csv-btn:hover {
            background-color: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .reason-header .download-csv-btn {
            background-color: var(--success-color);
            color: white;
        }

        .sequence-table-header .download-csv-btn {
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .sequence-table-header .download-csv-btn:hover {
            background-color: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }

        /* Mapping Section */
        .mapping-section {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .mapping-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .mapping-progress {
            background: linear-gradient(135deg, #e0e7ff 0%, #f0f4ff 100%);
            border: 2px solid var(--primary-color);
            border-radius: 12px;
            padding: 16px 24px;
            margin-bottom: 24px;
            text-align: center;
        }

        .mapping-progress-text {
            font-size: 14px;
            color: var(--text-light);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .mapping-progress-bar {
            width: 100%;
            height: 10px;
            background-color: rgba(99, 102, 241, 0.1);
            border-radius: 999px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .mapping-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color) 0%, var(--primary-light) 100%);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 999px;
        }

        .mapping-counter {
            font-size: 18px;
            font-weight: 700;
            color: var(--primary-color);
        }

        .mapping-message {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-dark) 100%);
            color: white !important;
            padding: 24px;
            border-radius: 12px;
            margin-bottom: 30px;
            text-align: center;
            box-shadow: var(--shadow-lg);
        }

        .mapping-message h3 {
            margin: 0 0 8px 0;
            font-size: 16px;
            opacity: 0.9;
            font-weight: 500;
        }

        .mapping-message .column-name {
            font-size: 28px;
            font-weight: 700;
            letter-spacing: -0.5px;
            margin: 0;
        }

        .column-selector-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 12px;
            margin-bottom: 30px;
        }

        .column-btn {
            background: linear-gradient(135deg, #ffffff 0%, #f9fafb 100%);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 16px 20px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-color);
            text-align: center;
            box-shadow: var(--shadow-sm);
            word-wrap: break-word;
        }

        .column-btn:hover:not(.disabled) {
            transform: translateY(-2px);
            box-shadow: var(--shadow);
            border-color: var(--primary-color);
            background: linear-gradient(135deg, #f0f4ff 0%, #e0e7ff 100%);
        }

        .column-btn.selected {
            background: linear-gradient(135deg, var(--success-color) 0%, #059669 100%);
            color: white;
            border-color: var(--success-color);
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
        }

        .column-btn.disabled {
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            color: var(--text-light);
            border-color: #d1d5db;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .column-btn.disabled:hover {
            transform: none;
            box-shadow: var(--shadow-sm);
        }

        .mapping-navigation {
            display: flex;
            justify-content: space-between;
            gap: 12px;
        }

        .mapping-navigation .btn {
            flex: 1;
            max-width: 200px;
        }

        .mapping-navigation .btn-prev {
            margin-right: auto;
        }

        .mapping-navigation .btn-next {
            margin-left: auto;
        }

        .mapping-info {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            border: 1px solid #93c5fd;
            border-radius: 10px;
            padding: 16px 20px;
            margin-bottom: 20px;
            color: #1e40af;
            font-size: 14px;
        }

        .mapping-info strong {
            font-weight: 600;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.5.0/lz-string.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>VURDHAAN CORSIA Report Generator</h1>
            <p>Validate your data and generate compliant reports with ease</p>
        </header>

        <!-- Alert Messages -->
        <div id="alertMessage" class="alert"></div>

        <!-- Upload Section -->
        <div id="uploadSection" class="card upload-section">
            <h2>Upload CSV File</h2>
            <p>Drag and drop your CSV file here or click to browse</p>
            <input type="file" id="fileInput" class="file-input" accept=".csv">
            <button class="upload-button" onclick="document.getElementById('fileInput').click()">
                Choose CSV File
            </button>
            <p class="file-info" id="fileInfo"></p>
        </div>

        <!-- Fuel Method Selection Section -->
        <div id="fuelMethodSection" class="card mapping-section">
            <h2>Fuel Calculation Method</h2>

            <div class="mapping-info">
                <strong>ℹ️ Info:</strong> Please select the fuel calculation method used in your data. This determines which fuel-related columns are required.
            </div>

            <div class="mapping-message">
                <h2 style="color: white;">Select Fuel Calculation Method:</h2>
            </div>

            <div class="column-selector-grid">
                <button type="button" class="column-btn" id="fuelMethodBlockOff" onclick="selectFuelMethod('Block Off - Block On')">
                    <div style="font-weight: 700; margin-bottom: 8px;">Block Off - Block On</div>
                    <div style="font-size: 12px; opacity: 0.8;">Uses Block Off Fuel and Block On Fuel columns</div>
                </button>
                <button type="button" class="column-btn" id="fuelMethodB" onclick="selectFuelMethod('Method B')">
                    <div style="font-weight: 700; margin-bottom: 8px;">Method B</div>
                    <div style="font-size: 12px; opacity: 0.8;">Uses Remaining Fuel, Uplift Weight, and Block On Fuel columns</div>
                </button>
            </div>

            <div class="mapping-navigation">
                <button type="button" class="btn btn-primary btn-next" id="fuelMethodNextBtn" onclick="completeFuelMethodSelection()" disabled>
                    Next →
                </button>
            </div>
        </div>

        <!-- Mapping Section -->
        <div id="mappingSection" class="card mapping-section">
            <h2>Column Mapping</h2>

            <div class="mapping-info">
                <strong>ℹ️ Info:</strong> Please map your CSV columns to the required fields. Select the column from your uploaded file that corresponds to each required field.
            </div>

            <div class="mapping-progress">
                <div class="mapping-progress-text">Mapping Progress</div>
                <div class="mapping-progress-bar">
                    <div class="mapping-progress-fill" id="mappingProgressFill"></div>
                </div>
                <div class="mapping-counter">
                    <span id="mappingCounter">0 of 15</span> columns mapped
                </div>
            </div>

            <div class="mapping-message">
                <h3 style="color: white;">Select the column for:</h3>
                <p class="column-name" id="currentRequiredColumn">Date</p>
            </div>

            <div class="column-selector-grid" id="columnSelectorGrid">
                <!-- Column buttons will be dynamically generated here -->
            </div>

            <div class="mapping-navigation">
                <button type="button" class="btn btn-secondary btn-prev" id="mappingPrevBtn" onclick="previousMappingStep()" style="display: none;">
                    ← Previous
                </button>
                <button type="button" class="btn btn-primary btn-next" id="mappingNextBtn" onclick="nextMappingStep()" disabled>
                    Next →
                </button>
                <button type="button" class="btn btn-success" id="mappingCompleteBtn" onclick="completeMappingSection()" style="display: none;">
                    Complete Mapping
                </button>
            </div>
        </div>

        <!-- Parameters Section -->
        <div id="parametersSection" class="card parameters-section">
            <h2>Validation Parameters</h2>
            <form id="parametersForm">
                <div class="form-grid">
                    <div class="form-group">
                        <label for="monitoringYear">Monitoring Year</label>
                        <select id="monitoringYear" name="monitoring_year" required>
                            <option value="2020">2020 (01/01/2020 - 31/12/2020)</option>
                            <option value="2021">2021 (01/01/2021 - 31/12/2021)</option>
                            <option value="2022">2022 (01/01/2022 - 31/12/2022)</option>
                            <option value="2023">2023 (01/01/2023 - 31/12/2023)</option>
                            <option value="2024" selected>2024 (01/01/2024 - 31/12/2024)</option>
                            <option value="2025">2025 (01/01/2025 - 31/12/2025)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="dateFormat">Date Format</label>
                        <select id="dateFormat" name="date_format" required>
                            <option value="DMY">DD/MM/YYYY</option>
                            <option value="MDY">MM/DD/YYYY</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="flightPrefix">Flight Starts With</label>
                        <input type="text" id="flightPrefix" name="flight_starts_with"
                               placeholder="e.g., AI, LH, FHY" required>
                    </div>
                </div>
                <div class="button-group">
                    <button type="submit" class="btn btn-primary">Start Validation</button>
                    <button type="button" class="btn btn-secondary" onclick="resetUpload()">Cancel</button>
                </div>
            </form>
        </div>

        <!-- Loading Section -->
        <div id="loadingSection" class="card loading">
            <div class="spinner"></div>
            <h3 id="loadingMessage">Processing CSV file...</h3>
            <div class="progress-bar" id="progressBar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <!-- Error Display Section -->
        <div id="errorSection" class="card error-section">
            <h2>Validation Errors</h2>
            <div class="summary-box">
                <h3>Summary</h3>
                <div class="summary-grid" id="errorStats"></div>
            </div>
            
            <div class="action-buttons-container">
                <!-- Primary Actions -->
                <div class="button-row primary-actions">
                    <button class="btn btn-success" onclick="saveCorrections()">
                        <span class="btn-icon">💾</span> Save Corrections
                    </button>
                    <button class="btn btn-danger" onclick="ignoreErrors()">
                        <span class="btn-icon">⚠️</span> Ignore Remaining Errors
                    </button>
                </div>
                
                <!-- Download Actions -->
                <div class="button-row download-actions">
                    <button class="btn btn-primary" onclick="downloadCleanCSV()">
                        <span class="btn-icon">📥</span> Download Clean Data CSV
                    </button>
                    <button class="btn btn-primary" onclick="downloadErrorsCSV()">
                        <span class="btn-icon">📥</span> Download Errors CSV
                    </button>
                </div>
                
                <!-- Analysis & Reset Actions -->
                <div class="button-row secondary-actions">
                    <button class="btn btn-primary btn-highlight" onclick="openChatSession()" id="chatButton">
                        <span class="btn-icon">💬</span> Analyze Data with AI Chat
                    </button>
                    <button class="btn btn-secondary" onclick="resetUpload()">
                        <span class="btn-icon">🔄</span> Start Over
                    </button>
                </div>
            </div>

            <div id="errorCategoriesContainer"></div>
        </div>

        <!-- Success Section -->
        <div id="successSection" class="card success-section">
            <div class="success-icon">✓</div>
            <h2>Validation Complete!</h2>
            <p>Your CSV file has been successfully validated.</p>
            <div class="action-buttons-container">
                <div class="button-row">
                    <button class="btn btn-primary btn-large" onclick="generateReport()">
                        <span class="btn-icon">📊</span> Generate CORSIA Report
                    </button>
                </div>
                <div class="button-row">
                    <button class="btn btn-success" onclick="downloadCleanCSV()">
                        <span class="btn-icon">📥</span> Download Clean Data CSV
                    </button>
                    <button class="btn btn-secondary" onclick="revalidate()">
                        <span class="btn-icon">🔄</span> Re-Validate & Process Again
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Function to apply error box styling to cells containing "Error:" or "Details:"
        function applyErrorBoxStyling() {
            const tables = document.querySelectorAll('.data-table, .error-row-table, .sequence-table');
            tables.forEach(table => {
                const cells = table.querySelectorAll('td');
                cells.forEach(cell => {
                    const text = cell.textContent || '';
                    if (text.includes('Error:') || text.includes('Details:')) {
                        cell.classList.add('error-info-cell');
                        // Wrap content in span for styling
                        if (!cell.querySelector('span')) {
                            cell.innerHTML = `<span>${cell.innerHTML}</span>`;
                        }
                    }
                });
            });
        }

        // Function to mark last rows in sequence groups
        function markLastInSequence() {
            const tables = document.querySelectorAll('.data-table, .error-row-table, .sequence-table');
            tables.forEach(table => {
                const rows = table.querySelectorAll('tr');
                rows.forEach((row, index) => {
                    if (row.classList.contains('sequence-error-row')) {
                        const nextRow = rows[index + 1];
                        if (!nextRow || !nextRow.classList.contains('sequence-error-row')) {
                            row.classList.add('last-in-sequence');
                        }
                    }
                });
            });
        }

        // Apply styling when tables are rendered
        const observer = new MutationObserver(() => {
            applyErrorBoxStyling();
            markLastInSequence();
        });

        // Initialize observer when DOM is ready
        function initErrorSectionObserver() {
            const errorSectionElement = document.getElementById('errorSection');
            if (errorSectionElement) {
                observer.observe(errorSectionElement, { childList: true, subtree: true });
            }
        }

        // CSV Download Helper Functions
        function escapeCSVField(field) {
            if (field === null || field === undefined) {
                return '';
            }
            
            let fieldStr = String(field);
            
            // If field contains comma, newline, or quote, wrap in quotes and escape internal quotes
            if (fieldStr.includes(',') || fieldStr.includes('\n') || fieldStr.includes('\r') || fieldStr.includes('"')) {
                fieldStr = '"' + fieldStr.replace(/"/g, '""') + '"';
            }
            
            return fieldStr;
        }

        function downloadCSV(data, filename) {
            try {
                console.log('📥 [DEBUG] Starting CSV download:', filename, 'Rows:', data.length);
                
                if (!data || data.length === 0) {
                    alert('No data available to download');
                    return;
                }
                
                // Get column headers from first row
                const columns = Object.keys(data[0]);
                
                // Create CSV content
                let csvContent = '';
                
                // Add header row
                csvContent += columns.map(col => escapeCSVField(col)).join(',') + '\n';
                
                // Add data rows
                data.forEach(row => {
                    const rowData = columns.map(col => {
                        const value = row[col];
                        return escapeCSVField(value);
                    });
                    csvContent += rowData.join(',') + '\n';
                });
                
                // Create and trigger download
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                
                if (link.download !== undefined) {
                    const url = URL.createObjectURL(blob);
                    link.setAttribute('href', url);
                    link.setAttribute('download', filename);
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    
                    console.log('✅ [DEBUG] CSV download completed');
                } else {
                    alert('Download not supported in this browser');
                }
                
            } catch (error) {
                console.error('💥 [DEBUG] CSV download failed:', error);
                alert('Failed to download CSV: ' + error.message);
            }
        }

        function downloadCategoryCSV(categoryIndex) {
            try {
                const category = errorData.categories[categoryIndex];
                const categoryName = category.name.replace(/[^a-zA-Z0-9]/g, '_');
                const filename = `${categoryName}_errors.csv`;
                
                console.log('📂 [DEBUG] Downloading category CSV:', categoryName);
                
                const allRowsData = [];
                
                // Process each error group in the category
                category.errors.forEach(errorGroup => {
                    errorGroup.rows.forEach(rowError => {
                        if (!rowError.file_level) {
                            const rowData = errorData.rows_data[rowError.row_idx] || {};
                            const enrichedRow = {
                                'Error_Category': category.name,
                                'Error_Reason': errorGroup.reason,
                                'Error_Details': rowError.cell_data || '',
                                'Row_Index': rowError.row_idx,
                                ...rowData
                            };
                            allRowsData.push(enrichedRow);
                        }
                    });
                });
                
                downloadCSV(allRowsData, filename);
                
            } catch (error) {
                console.error('💥 [DEBUG] Category CSV download failed:', error);
                alert('Failed to download category CSV: ' + error.message);
            }
        }

        function downloadReasonGroupCSV(categoryIndex, reasonIndex) {
            try {
                const category = errorData.categories[categoryIndex];
                const errorGroup = category.errors[reasonIndex];
                const reasonName = errorGroup.reason.replace(/[^a-zA-Z0-9]/g, '_');
                const filename = `${reasonName}_errors.csv`;
                
                console.log('📊 [DEBUG] Downloading reason group CSV:', reasonName);
                
                const reasonRowsData = [];
                
                errorGroup.rows.forEach(rowError => {
                    if (!rowError.file_level) {
                        const rowData = errorData.rows_data[rowError.row_idx] || {};
                        const enrichedRow = {
                            'Error_Category': category.name,
                            'Error_Reason': errorGroup.reason,
                            'Error_Details': rowError.cell_data || '',
                            'Row_Index': rowError.row_idx,
                            ...rowData
                        };
                        reasonRowsData.push(enrichedRow);
                    }
                });
                
                downloadCSV(reasonRowsData, filename);
                
            } catch (error) {
                console.error('💥 [DEBUG] Reason group CSV download failed:', error);
                alert('Failed to download reason group CSV: ' + error.message);
            }
        }

        function downloadSequenceTableCSV(sequenceContainer) {
            try {
                const table = sequenceContainer.querySelector('.sequence-table');
                if (!table) {
                    alert('No table found to download');
                    return;
                }
                
                const headerText = sequenceContainer.querySelector('.sequence-table-header').textContent;
                const filename = `${headerText.replace(/[^a-zA-Z0-9]/g, '_')}.csv`;
                
                console.log('🔄 [DEBUG] Downloading sequence table CSV:', filename);
                
                const tableData = [];
                const headers = [];
                
                // Get headers
                const headerRow = table.querySelector('thead tr');
                if (headerRow) {
                    headerRow.querySelectorAll('th').forEach(th => {
                        headers.push(th.textContent.trim());
                    });
                }
                
                // Get data rows
                const dataRows = table.querySelectorAll('tbody tr');
                dataRows.forEach(row => {
                    const rowData = {};
                    row.querySelectorAll('td').forEach((td, index) => {
                        const input = td.querySelector('input');
                        const cellValue = input ? input.value : td.textContent.trim();
                        rowData[headers[index] || `Column_${index + 1}`] = cellValue;
                    });
                    tableData.push(rowData);
                });
                
                downloadCSV(tableData, filename);
                
            } catch (error) {
                console.error('💥 [DEBUG] Sequence table CSV download failed:', error);
                alert('Failed to download sequence table CSV: ' + error.message);
            }
        }

        // Global variables
        let currentFileId = null;
        let currentChunk = 1;
        let errorData = null;
        let editedCells = {};
        let validationParams = {};
        let sequenceErrors = new Map(); // NEW: Store sequence errors for highlighting

        // Mapping-related variables
        let uploadedColumns = [];
        let columnMapping = [];
        let currentMappingIndex = 0;
        let selectedColumnForCurrentStep = null;
        let currentFile = null;
        let selectedFuelMethod = null;

        // DOM elements - will be initialized when DOM is ready
        let uploadSection;
        let parametersSection;
        let loadingSection;
        let successSection;
        let alertMessage;
        let fileInput;
        let fileInfo;
        let fuelMethodSection;
        let mappingSection;
        let errorSection;

        // Define column orders for different fuel methods
        const fuelMethodColumns = {
            "Block Off - Block On": [
                "Date",
                "A/C Registration",
                "Flight No",
                "A/C Type",
                "ATD (UTC) Block Off",
                "ATA (UTC) Block On",
                "Origin ICAO",
                "Destination ICAO",
                "Block Off Fuel",
                "Block On Fuel",
                "Fuel Consumption"
            ],
            "Method B": [
                "Date",
                "A/C Registration",
                "Flight No",
                "A/C Type",
                "ATD (UTC) Block Off",
                "ATA (UTC) Block On",
                "Origin ICAO",
                "Destination ICAO",
                "Uplift weight",
                "Remaining Fuel From Prev. Flight",
                "Block On Fuel",
                "Fuel Consumption"
            ]
        };

        // Get current column order based on selected fuel method
        function getColumnOrder() {
            return fuelMethodColumns[selectedFuelMethod] || [];
        }

        // NEW: Function to parse error sequence from cell_data
        function parseErrorSequence(cellData) {
            if (!cellData) return null;

            // Ensure cellData is a string
            if (typeof cellData !== 'string') {
                return null;
            }

            // Match pattern like "TCCOH : LTAF → LTAI"
            const match = cellData.match(/(\w+)\s*:\s*(\w+)\s*→\s*(\w+)/);
            if (match) {
                console.log(match)
                return {
                    errorCode: match[1], // TCCOH
                    destinationICAO: match[2], // LTAF
                    originICAO: match[3] // LTAI
                };
            }
            return null;
        }

        // NEW: Function to group rows by cell_data and determine highlighting
        function processSequenceGroups(errorGroup) {
            // Group rows by cell_data
            const groups = new Map();
            
            errorGroup.rows.forEach((rowError, index) => {
                if (rowError.cell_data) {
                    const sequence = parseErrorSequence(rowError.cell_data);
                    if (sequence) {
                        const key = rowError.cell_data; // Use full cell_data as key
                        if (!groups.has(key)) {
                            groups.set(key, []);
                        }
                        groups.get(key).push({ rowError, originalIndex: index });
                    }
                }
            });

            // Determine which rows should be highlighted
            const highlightMap = new Map();
            
            groups.forEach((groupRows, cellData) => {
                if (groupRows.length === 4) {
                    // Highlight 2nd and 3rd rows (indices 1 and 2)
                    highlightMap.set(groupRows[1].rowError.row_idx, true);
                    highlightMap.set(groupRows[2].rowError.row_idx, true);
                }
                
                // Collect sequence for final summary
                if (groupRows.length > 0) {
                    const sequence = parseErrorSequence(cellData);
                    if (sequence) {
                        const key = `${sequence.errorCode}_${sequence.destinationICAO}_${sequence.originICAO}`;
                        sequenceErrors.set(key, sequence);
                    }
                }
            });

            return { groups, highlightMap };
        }

        // NEW: Function to create final sequence error summary
        function createFinalSequenceSummary() {
            if (sequenceErrors.size === 0) return;

            // Find or create a container at the end of the error section
            let summaryContainer = document.getElementById('finalSequenceSummary');
            if (!summaryContainer) {
                summaryContainer = document.createElement('div');
                summaryContainer.id = 'finalSequenceSummary';
                summaryContainer.className = 'sequence-summary';
                summaryContainer.style.marginTop = '30px';
                
                const errorSection = document.getElementById('errorSection');
                errorSection.appendChild(summaryContainer);
            }

            summaryContainer.innerHTML = '';
            
            const title = document.createElement('h4');
            title.textContent = 'Sequence Error Summary';
            summaryContainer.appendChild(title);

            // Create one summary item per unique error
            for (let [key, sequence] of sequenceErrors) {
                const item = document.createElement('div');
                item.className = 'sequence-summary-item';
                item.innerHTML = `
                    <strong>Error:</strong> ${sequence.errorCode}: Sequence Failed for Destination ICAO: ${sequence.destinationICAO} to Origin ICAO: ${sequence.originICAO}<br>
                    <strong>Details:</strong> ${sequence.errorCode} : ${sequence.destinationICAO} → ${sequence.originICAO}
                `;
                summaryContainer.appendChild(item);
            }
        }

        // ============================================================================
        // FUEL METHOD SELECTION FUNCTIONS
        // ============================================================================

        /**
         * Select fuel calculation method
         */
        function selectFuelMethod(method) {
            selectedFuelMethod = method;

            // Update button states
            document.getElementById('fuelMethodBlockOff').classList.remove('selected');
            document.getElementById('fuelMethodB').classList.remove('selected');

            if (method === 'Block Off - Block On') {
                document.getElementById('fuelMethodBlockOff').classList.add('selected');
            } else if (method === 'Method B') {
                document.getElementById('fuelMethodB').classList.add('selected');
            }

            // Enable next button
            document.getElementById('fuelMethodNextBtn').disabled = false;

            console.log('Selected fuel method:', selectedFuelMethod);
        }

        /**
         * Complete fuel method selection and proceed to column mapping
         */
        function completeFuelMethodSelection() {
            if (!selectedFuelMethod) {
                showAlert('Please select a fuel calculation method.', 'error');
                return;
            }

            console.log('Fuel method selected:', selectedFuelMethod);

            // Hide fuel method section and show mapping section
            fuelMethodSection.style.display = 'none';
            showMappingSection();
        }

        /**
         * Show fuel method selection section
         */
        function showFuelMethodSection() {
            uploadSection.style.display = 'none';
            fuelMethodSection.style.display = 'block';
        }

        // ============================================================================
        // COLUMN MAPPING FUNCTIONS
        // ============================================================================

        /**
         * Read CSV columns from uploaded file
         */
        async function readCSVColumns(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const text = e.target.result;
                        const firstLine = text.split('\n')[0].trim();
                        // Remove quotes and trim whitespace to match backend processing
                        const columns = firstLine.split(',').map(col => col.replace(/^["']|["']$/g, '').trim());
                        console.log('Detected CSV columns:', columns);
                        console.log('Column count:', columns.length);
                        resolve(columns);
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        /**
         * Show mapping section and initialize
         */
        async function showMappingSection() {
            try {
                // Read columns from the uploaded file
                uploadedColumns = await readCSVColumns(currentFile);

                const columnOrder = getColumnOrder();
                const requiredColumnCount = columnOrder.length;

                // Validate minimum columns
                if (uploadedColumns.length < requiredColumnCount) {
                    showAlert(`CSV file must have at least ${requiredColumnCount} columns. Found ${uploadedColumns.length} columns.`, 'error');
                    resetUpload();
                    return;
                }

                // Initialize mapping state
                columnMapping = new Array(requiredColumnCount).fill(null);
                currentMappingIndex = 0;
                selectedColumnForCurrentStep = null;

                // Show mapping section
                mappingSection.style.display = 'block';

                // Render first step
                renderMappingStep(0);

            } catch (error) {
                console.error('Error reading CSV columns:', error);
                showAlert('Failed to read CSV columns: ' + error.message, 'error');
                resetUpload();
            }
        }

        /**
         * Render the current mapping step
         */
        function renderMappingStep(index) {
            currentMappingIndex = index;
            const columnOrder = getColumnOrder();
            const requiredColumn = columnOrder[index];
            const totalColumns = columnOrder.length;

            // Update UI
            document.getElementById('currentRequiredColumn').textContent = requiredColumn;
            document.getElementById('mappingCounter').textContent = `${index} of ${totalColumns}`;

            // Update progress bar
            const progress = (index / totalColumns) * 100;
            document.getElementById('mappingProgressFill').style.width = progress + '%';

            // Render column selector buttons
            const grid = document.getElementById('columnSelectorGrid');
            grid.innerHTML = '';

            uploadedColumns.forEach(column => {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'column-btn';
                button.textContent = column;
                button.dataset.column = column;

                // Check if this column was already selected for current step
                if (columnMapping[index] === column) {
                    button.classList.add('selected');
                    selectedColumnForCurrentStep = column;
                }

                // Check if this column was already mapped to a previous step
                const alreadyMapped = columnMapping.slice(0, index).includes(column);
                if (alreadyMapped) {
                    button.classList.add('disabled');
                    button.disabled = true;
                } else {
                    button.addEventListener('click', () => selectColumn(column));
                }

                grid.appendChild(button);
            });

            // Update navigation buttons
            updateNavigationButtons();
        }

        /**
         * Handle column selection
         */
        function selectColumn(columnName) {
            // Update mapping
            columnMapping[currentMappingIndex] = columnName;
            selectedColumnForCurrentStep = columnName;

            // Update UI
            renderMappingStep(currentMappingIndex);
        }

        /**
         * Update navigation button states
         */
        function updateNavigationButtons() {
            const prevBtn = document.getElementById('mappingPrevBtn');
            const nextBtn = document.getElementById('mappingNextBtn');
            const completeBtn = document.getElementById('mappingCompleteBtn');
            const columnOrder = getColumnOrder();
            const totalColumns = columnOrder.length;

            // Previous button
            if (currentMappingIndex > 0) {
                prevBtn.style.display = 'inline-block';
            } else {
                prevBtn.style.display = 'none';
            }

            // Next/Complete button
            if (currentMappingIndex < totalColumns - 1) {
                // Not on last step
                nextBtn.style.display = 'inline-block';
                completeBtn.style.display = 'none';
                nextBtn.disabled = !columnMapping[currentMappingIndex];
            } else {
                // On last step
                nextBtn.style.display = 'none';
                completeBtn.style.display = 'inline-block';
                completeBtn.disabled = !columnMapping[currentMappingIndex];
            }
        }

        /**
         * Go to next mapping step
         */
        function nextMappingStep() {
            const columnOrder = getColumnOrder();
            const totalColumns = columnOrder.length;
            if (currentMappingIndex < totalColumns - 1 && columnMapping[currentMappingIndex]) {
                renderMappingStep(currentMappingIndex + 1);
            }
        }

        /**
         * Go to previous mapping step
         */
        function previousMappingStep() {
            if (currentMappingIndex > 0) {
                renderMappingStep(currentMappingIndex - 1);
            }
        }

        /**
         * Complete mapping and proceed to parameters
         */
        function completeMappingSection() {
            const columnOrder = getColumnOrder();
            const totalColumns = columnOrder.length;

            // Validate all columns are mapped
            const unmappedIndices = [];
            columnMapping.forEach((col, idx) => {
                if (!col) unmappedIndices.push(idx);
            });

            if (unmappedIndices.length > 0) {
                showAlert(`Please map all ${totalColumns} columns before proceeding.`, 'error');
                return;
            }

            console.log('Column mapping completed:', columnMapping);
            console.log('Fuel method:', selectedFuelMethod);

            // Hide mapping section and show parameters section
            mappingSection.style.display = 'none';
            parametersSection.style.display = 'block';
        }

        // Initialize DOM elements and event listeners

        document.addEventListener('DOMContentLoaded', function() {
            // Initialize DOM element references
            uploadSection = document.getElementById('uploadSection');
            parametersSection = document.getElementById('parametersSection');
            loadingSection = document.getElementById('loadingSection');
            successSection = document.getElementById('successSection');
            alertMessage = document.getElementById('alertMessage');
            fileInput = document.getElementById('fileInput');
            fileInfo = document.getElementById('fileInfo');
            fuelMethodSection = document.getElementById('fuelMethodSection');
            mappingSection = document.getElementById('mappingSection');
            errorSection = document.getElementById('errorSection');
            
            // Setup event handlers
            setupDragDrop();
            setupFileInput();
            setupParametersForm();
            
            // Initialize error section observer
            initErrorSectionObserver();
            
            // Apply initial styling
            applyErrorBoxStyling();
            markLastInSequence();
        });

        // File upload handling
        function setupDragDrop() {
            if (!uploadSection) {
                console.error('Upload section not found - drag and drop cannot be initialized');
                return;
            }
            
            const dropZone = uploadSection;
            
            // Prevent default drag behaviors on the entire document
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                document.body.addEventListener(eventName, preventDefaults, false);
            });
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            // Highlight drop zone when item is dragged over it
            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, highlight, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, unhighlight, false);
            });
            
            function highlight(e) {
                preventDefaults(e);
                dropZone.classList.add('dragover');
            }
            
            function unhighlight(e) {
                preventDefaults(e);
                dropZone.classList.remove('dragover');
            }
            
            // Handle dropped files
            dropZone.addEventListener('drop', handleDrop, false);
            
            console.log('Drag and drop initialized successfully');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const dt = e.dataTransfer;
            const files = dt.files;
            
            console.log('File dropped:', files.length, 'files');
            
            if (files.length > 0) {
                handleFile(files[0]);
            } else {
                showAlert('No file was dropped', 'error');
            }
        }

        function setupFileInput() {
            fileInput.addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    handleFile(e.target.files[0]);
                }
            });
        }

        function handleFile(file) {
            if (!file.name.endsWith('.csv')) {
                showAlert('Please select a CSV file', 'error');
                return;
            }

            // Store file for later use
            currentFile = file;

            fileInfo.textContent = `Selected: ${file.name} (${formatFileSize(file.size)})`;

            // Show fuel method selection section
            showFuelMethodSection();
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Parameters form handling
        function setupParametersForm() {
            const form = document.getElementById('parametersForm');
            form.addEventListener('submit', async function(e) {
                e.preventDefault();
                
                // Collect parameters
                const monitoringYear = document.getElementById('monitoringYear').value;
                validationParams = {
                    start_date: `${monitoringYear}-01-01`,
                    end_date: `${monitoringYear}-12-31`,
                    monitoring_year: monitoringYear,
                    date_format: document.getElementById('dateFormat').value,
                    flight_starts_with: document.getElementById('flightPrefix').value
                };
                
                // Upload file
                await uploadFile();
            });
        }

        // File upload to server
        async function uploadFile() {
            // Use currentFile (supports both drag-drop and file input)
            const file = currentFile || fileInput.files[0];
            if (!file) {
                showAlert('No file selected. Please select a file first.', 'error');
                return;
            }

            showLoading('Uploading file...');

            const formData = new FormData();
            formData.append('file', file);

            // Add validation parameters
            Object.keys(validationParams).forEach(key => {
                formData.append(key, validationParams[key]);
            });

            // Add column mapping as JSON string
            const columnOrder = getColumnOrder();
            if (columnMapping && columnMapping.length === columnOrder.length) {
                formData.append('column_mapping', JSON.stringify(columnMapping));
                console.log('Sending column mapping:', columnMapping);
            }

            // Add fuel method
            if (selectedFuelMethod) {
                formData.append('fuel_method', selectedFuelMethod);
                console.log('Sending fuel method:', selectedFuelMethod);
            }

            try {
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error('Upload failed');
                }

                const data = await response.json();
                currentFileId = data.file_id;

                // Start fetching errors
                await fetchErrors();

            } catch (error) {
                showAlert('Failed to upload file: ' + error.message, 'error');
                hideLoading();
            }
        }

        // Fetch errors in chunks
        async function fetchErrors() {
            showLoading('Loading validation results...');
            
            try {
                console.log('Fetching errors for file ID:', currentFileId);
                
                // Fetch the error data (could be compressed or regular JSON)
                const response = await fetch(`/errors/${currentFileId}`);
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Server response not OK:', response.status, errorText);
                    throw new Error(`Failed to fetch errors: ${response.status} ${errorText}`);
                }
                
                // Check response headers to determine if data is compressed
                const contentType = response.headers.get('content-type');
                const compressionType = response.headers.get('x-compression');
                
                let data;
                
                if (compressionType === 'lzstring' || contentType === 'text/plain') {
                    // Handle LZ-String compressed data
                    console.log('Decompressing LZ-String data...');
                    const compressedData = await response.text();
                    
                    // Log compression details
                    console.log(`Received compressed data: ${compressedData.length.toLocaleString()} characters`);
                    
                    data = await decompressLZStringErrorReport(compressedData);
                    console.log('Decompression completed successfully');
                } else {
                    // Handle regular JSON (fallback for compatibility)
                    console.log('Processing regular JSON data...');
                    data = await response.json();
                }
                
                console.log('Received error data:', data);
                
                if (!data) {
                    throw new Error('Received empty error data');
                }
                
                errorData = data;
                hideLoading();
                
                // Check if there are errors
                if (!errorData.summary) {
                    console.error('Missing summary in error data:', errorData);
                    throw new Error('Invalid error data format: missing summary');
                }
                
                console.log('Error summary:', errorData.summary);
                
                if (errorData.summary.total_errors > 0) {
                    // Immediately show error page
                    displayErrors();
                } else {
                    // No errors, proceed to success
                    showSuccess();
                }
                
            } catch (error) {
                console.error('Error in fetchErrors:', error);
                console.error('Error stack:', error.stack);
                showAlert('Failed to load errors: ' + error.message, 'error');
                hideLoading();
            }
        }

        /**
         * Decompresses LZ-String compressed optimized error report and restores original structure
         * @param {string} compressedData - The LZ-String compressed data
         * @returns {Object} - Restored error report in original format
         */
        async function decompressLZStringErrorReport(compressedData) {
            try {
                console.log('Starting LZ-String decompression...');
                
                // Check if LZString is available
                if (typeof LZString === 'undefined') {
                    throw new Error('LZ-String library not loaded. Please check your internet connection and try again.');
                }
                
                // Step 1: LZ-String decompression
                const jsonStr = LZString.decompressFromBase64(compressedData);
                
                if (!jsonStr) {
                    throw new Error('Failed to decompress data. The data may be corrupted.');
                }
                
                // Parse the decompressed JSON
                const optimizedData = JSON.parse(jsonStr);
                
                console.log(`LZ-String decompression successful: ${compressedData.length.toLocaleString()} → ${jsonStr.length.toLocaleString()} characters`);
                console.log(`Compression ratio: ${((1 - compressedData.length / jsonStr.length) * 100).toFixed(1)}%`);
                
                // Step 2: Restore original structure
                return restoreOriginalErrorStructure(optimizedData);
                
            } catch (error) {
                console.error('Decompression failed:', error);
                
                // Provide helpful error messages
                if (error.message.includes('LZString')) {
                    throw new Error('LZ-String decompression library failed to load. Please check your internet connection.');
                } else if (error.message.includes('JSON')) {
                    throw new Error('Failed to parse decompressed data. The data may be corrupted.');
                } else {
                    throw new Error(`Failed to decompress error data: ${error.message}`);
                }
            }
        }

        /**
         * Restores the original error report structure from optimized format
         * @param {Object} optimizedData - The optimized/compressed data structure
         * @returns {Object} - Original error report structure
         */
        function restoreOriginalErrorStructure(optimizedData) {
            try {
                console.log('Restoring original error structure...');
                
                // Validate input structure
                if (!optimizedData || !optimizedData.meta) {
                    throw new Error('Invalid optimized data structure: missing meta section');
                }
                
                // Get field mapping for restoration
                const fieldMap = optimizedData.meta.fm; // field map
                if (!fieldMap) {
                    throw new Error('Invalid optimized data structure: missing field map');
                }
                
                // Step 1: Restore row data with full field names
                const restoredRows = {};
                const rowsData = optimizedData.rd || {};
                
                for (const [rowIdx, rowData] of Object.entries(rowsData)) {
                    const restoredRow = {};
                    
                    for (const [shortKey, value] of Object.entries(rowData)) {
                        if (shortKey === 'err') {
                            // Handle error field
                            restoredRow['error'] = value;
                        } else {
                            // Restore full field name
                            const fullKey = fieldMap[shortKey] || shortKey;
                            restoredRow[fullKey] = value;
                        }
                    }
                    
                    restoredRows[rowIdx] = restoredRow;
                }
                
                // Step 2: Restore category structure
                const categories = optimizedData.c || [];
                const restoredCategories = categories.map(category => ({
                    name: category.n || '', // name
                    errors: (category.e || []).map(error => ({ // errors
                        reason: error.r || '', // reason
                        rows: (error.rows || []).map(row => {
                            if (row.fl) { // file_level
                                return {
                                    file_level: true,
                                    cell_data: row.cd || '',
                                    columns: row.cols || []
                                };
                            } else {
                                return {
                                    row_idx: row.idx,
                                    cell_data: row.cd || '',
                                    columns: row.cols || []
                                };
                            }
                        })
                    }))
                }));
                
                // Step 3: Restore summary structure
                const summary = optimizedData.meta.s || {};
                const restoredSummary = {
                    total_errors: summary.te || 0,
                    error_rows: summary.er || 0,
                    categories: summary.c || {}
                };
                
                // Step 4: Construct final restored structure
                const restoredData = {
                    summary: restoredSummary,
                    rows_data: restoredRows,
                    categories: restoredCategories
                };
                
                console.log('Structure restoration completed');
                console.log('Restored data summary:', restoredData.summary);
                
                // Validate restored structure
                if (!restoredData.summary || typeof restoredData.summary.total_errors !== 'number') {
                    throw new Error('Restored data validation failed: invalid summary structure');
                }
                
                return restoredData;
                
            } catch (error) {
                console.error('Failed to restore error structure:', error);
                throw new Error(`Structure restoration failed: ${error.message}`);
            }
        }

        /**
         * Check if LZ-String is loaded and working
         * @returns {boolean} - True if LZ-String is available
         */
        function isLZStringSupported() {
            return typeof LZString !== 'undefined' && 
                typeof LZString.compressToBase64 === 'function' &&
                typeof LZString.decompressFromBase64 === 'function';
        }

        // NEW: Function to create sequence table
        function createSequenceTable(sequence, rows) {
            const container = document.createElement('div');
            container.className = 'sequence-table-container';

            // Create header
            const header = document.createElement('div');
            header.className = 'sequence-table-header';
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between';
            header.style.alignItems = 'center';
            
            const headerText = document.createElement('span');
            headerText.textContent = `Sequence Error: ${sequence.errorCode}`;
            
            const downloadBtn = document.createElement('button');
            downloadBtn.className = 'download-csv-btn';
            downloadBtn.title = 'Download Sequence Table as CSV';
            downloadBtn.innerHTML = `
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7,10 12,15 17,10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                </svg>
            `;
            downloadBtn.onclick = (e) => {
                e.stopPropagation();
                downloadSequenceTableCSV(container);
            };
            
            header.appendChild(headerText);
            header.appendChild(downloadBtn);
            container.appendChild(header);

            // Create table
            const table = document.createElement('table');
            table.className = 'sequence-table';

            // Create header row
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            const columnOrder = getColumnOrder();
            columnOrder.forEach(column => {
                const th = document.createElement('th');
                th.textContent = column;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            // Create body
            const tbody = document.createElement('tbody');

            // Find mismatched sequence cells
            let highlightCells = [];
            for (let i = 0; i < rows.length - 1; i++) {
                const currentRow = rows[i].rowData;
                const nextRow = rows[i + 1].rowData;
                if (currentRow['Destination ICAO'] !== nextRow['Origin ICAO']) {
                    highlightCells.push({rowIdx: i, col: 'Destination ICAO'});
                    highlightCells.push({rowIdx: i + 1, col: 'Origin ICAO'});
                }
            }
            // Debug: log which cells will be highlighted
            console.log('Highlighting cells:', highlightCells);

            // Add all rows
            rows.forEach(({ rowError, rowData }, idx) => {
                const tr = document.createElement('tr');
                if (rowError.highlight) {
                    tr.className = 'sequence-error-row';
                }
                columnOrder.forEach(column => {
                    const td = document.createElement('td');
                    const value = rowData[column];
                    // Highlight only the specific cell if it matches
                    if (highlightCells.some(hc => hc.rowIdx === idx && hc.col === column)) {
                        td.classList.add('red-highlight');
                    }
                    // Remove input for Origin ICAO and Destination ICAO, always show as plain text
                    if ((column === 'Origin ICAO' || column === 'Destination ICAO')) {
                        td.textContent = value || '';
                    } else if (rowError.editableColumns.includes(column)) {
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.className = 'editable-input';
                        input.value = value || '';
                        input.dataset.row = rowError.row_idx;
                        input.dataset.column = column;
                        input.dataset.originalValue = value || '';
                        input.addEventListener('change', function() {
                            const key = `${rowError.row_idx}-${column}`;
                            if (this.value !== this.dataset.originalValue) {
                                editedCells[key] = {
                                    row: parseInt(rowError.row_idx),
                                    column: column,
                                    old_value: this.dataset.originalValue,
                                    new_value: this.value
                                };
                            } else {
                                delete editedCells[key];
                            }
                        });
                        td.appendChild(input);
                    } else {
                        td.textContent = value || '';
                    }
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            table.appendChild(tbody);
            container.appendChild(table);
            // Add sequence summary
            const summary = document.createElement('div');
            summary.className = 'sequence-summary';
            summary.innerHTML = `
                <div class="sequence-summary-item">
                    <strong>Error:</strong> ${sequence.errorCode}: Sequence Failed for Destination ICAO: ${sequence.destinationICAO} to Origin ICAO: ${sequence.originICAO}<br>
                    <strong>Details:</strong> ${sequence.errorCode} : ${sequence.destinationICAO} → ${sequence.originICAO}
                </div>
            `;
            container.appendChild(summary);
            return container;
        }

        // Helper to render error rows in batches for non-sequence errors
        function renderErrorRowsInBatches(errorGroup, reasonContent, batchSize = 100) {
            let currentIndex = 0;
            const totalRows = errorGroup.rows.length;

            function renderBatch() {
                const end = Math.min(currentIndex + batchSize, totalRows);
                for (let i = currentIndex; i < end; i++) {
                    const rowError = errorGroup.rows[i];
                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'error-row';

                    const detailsDiv = document.createElement('div');
                    detailsDiv.className = 'error-details';

                    if (rowError.file_level) {
                        detailsDiv.innerHTML = `
                            <div class="error-detail">
                                <strong>Type:</strong> File-level error
                            </div>
                            <div class="error-detail">
                                <strong>Columns:</strong> ${rowError.columns.join(', ')}
                            </div>
                        `;
                    } else {
                        const rowData = errorData.rows_data[rowError.row_idx] || {};
                        const table = document.createElement('table');
                        table.className = 'data-table';
                        const thead = document.createElement('thead');
                        const headerRow = document.createElement('tr');
                        const editableColumns = rowError.columns.flat();
                        const columnOrder = getColumnOrder();
                        columnOrder.forEach(column => {
                            const th = document.createElement('th');
                            th.textContent = column;
                            if (editableColumns.includes(column)) {
                                th.style.backgroundColor = '#fff3cd';
                            }
                            headerRow.appendChild(th);
                        });
                        thead.appendChild(headerRow);
                        table.appendChild(thead);
                        const tbody = document.createElement('tbody');
                        const dataRow = document.createElement('tr');
                        columnOrder.forEach(column => {
                            const td = document.createElement('td');
                            const value = rowData[column];
                            if (editableColumns.includes(column)) {
                                td.className = 'error-column';
                                const input = document.createElement('input');
                                input.type = 'text';
                                input.className = 'editable-input';
                                input.value = value || '';
                                input.dataset.row = rowError.row_idx;
                                input.dataset.column = column;
                                input.dataset.originalValue = value || '';
                                input.addEventListener('change', function() {
                                    const key = `${rowError.row_idx}-${column}`;
                                    if (this.value !== this.dataset.originalValue) {
                                        editedCells[key] = {
                                            row: parseInt(rowError.row_idx),
                                            column: column,
                                            old_value: this.dataset.originalValue,
                                            new_value: this.value
                                        };
                                    } else {
                                        delete editedCells[key];
                                    }
                                });
                                td.appendChild(input);
                            } else {
                                td.textContent = value || '';
                            }
                            dataRow.appendChild(td);
                        });
                        tbody.appendChild(dataRow);
                        table.appendChild(tbody);
                        const errorMessage = document.createElement('div');
                        errorMessage.className = 'error-message';
                        errorMessage.innerHTML = `
                            <strong>Error:</strong> ${errorGroup.reason}
                            <br>
                            <strong>Details:</strong> ${rowError.cell_data || ''}
                        `;
                        detailsDiv.appendChild(errorMessage);
                        detailsDiv.appendChild(table);
                    }
                    rowDiv.appendChild(detailsDiv);
                    reasonContent.appendChild(rowDiv);
                }
                currentIndex = end;
                // Remove any existing load more button
                const oldBtn = reasonContent.querySelector('.load-more-btn');
                if (oldBtn) oldBtn.remove();
                if (currentIndex < totalRows) {
                    const loadMoreBtn = document.createElement('button');
                    loadMoreBtn.textContent = `Load More Errors (${totalRows - currentIndex} remaining)`;
                    loadMoreBtn.className = 'btn btn-primary load-more-btn';
                    loadMoreBtn.style.margin = '20px auto 0 auto';
                    loadMoreBtn.onclick = renderBatch;
                    reasonContent.appendChild(loadMoreBtn);
                }
            }
            renderBatch();
        }

        function displayErrors() {
            try {
                console.log('Displaying errors...');
                console.log('Error data:', errorData);
                
                // Clear previous sequence errors
                sequenceErrors.clear();
                
                // Update error stats
                const errorStats = document.getElementById('errorStats');
                if (!errorStats) {
                    throw new Error('Error stats element not found');
                }
                
                // Calculate total errors correctly
                const totalErrors = errorData.categories.reduce((sum, category) => 
                    sum + category.errors.reduce((catSum, errorGroup) => 
                        catSum + errorGroup.rows.length, 0), 0);
                
                // Calculate unique error rows
                const errorRows = new Set();
                errorData.categories.forEach(category => {
                    category.errors.forEach(errorGroup => {
                        errorGroup.rows.forEach(rowError => {
                            if (!rowError.file_level) {
                                errorRows.add(rowError.row_idx);
                            }
                        });
                    });
                });
                
                const stats = {
                    total_errors: totalErrors,
                    error_rows: errorRows.size
                };
                
                errorStats.innerHTML = `
                    <div class="summary-item error">
                        <span>${stats.total_errors}</span>
                        Total Errors
                    </div>
                    <div class="summary-item error">
                        <span>${stats.error_rows}</span>
                        Affected Rows
                    </div>
                `;
                
                // Update error categories
                const container = document.getElementById('errorCategoriesContainer');
                if (!container) {
                    throw new Error('Error categories container not found');
                }
                
                container.innerHTML = '';
                
                // Process each category
                errorData.categories.forEach((category, catIndex) => {
                    console.log('Processing category:', category.name);
                    
                    const categoryDiv = document.createElement('div');
                    categoryDiv.className = 'category';
                    
                    // Category header
                    const header = document.createElement('div');
                    header.className = 'category-header';
                    
                    const categoryName = document.createElement('div');
                    categoryName.className = 'category-name';
                    categoryName.textContent = category.name;
                    
                    const categoryInfo = document.createElement('div');
                    categoryInfo.style.display = 'flex';
                    categoryInfo.style.alignItems = 'center';
                    
                    const categoryCount = document.createElement('div');
                    categoryCount.className = 'category-count';
                    categoryCount.textContent = `${category.errors.reduce((sum, err) => sum + err.rows.length, 0)} errors`;
                    
                    const downloadBtn = document.createElement('button');
                    downloadBtn.className = 'download-csv-btn';
                    downloadBtn.title = 'Download Category as CSV';
                    downloadBtn.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                            <polyline points="7,10 12,15 17,10"/>
                            <line x1="12" y1="15" x2="12" y2="3"/>
                        </svg>
                    `;
                    downloadBtn.onclick = (e) => {
                        e.stopPropagation();
                        downloadCategoryCSV(catIndex);
                    };
                    
                    categoryInfo.appendChild(categoryCount);
                    categoryInfo.appendChild(downloadBtn);
                    
                    header.appendChild(categoryName);
                    header.appendChild(categoryInfo);
                    header.onclick = () => toggleCategory(catIndex);
                    
                    // Category content
                    const content = document.createElement('div');
                    content.className = 'category-content';
                    content.id = `category-content-${catIndex}`;
                    
                    // Process each error group
                    category.errors.forEach(errorGroup => {
                        console.log('Processing error group:', errorGroup.reason);
                        
                        // Check if this is a sequence error group
                        const isSequenceError = errorGroup.rows.some(row => 
                            row.cell_data && parseErrorSequence(row.cell_data));
                        
                        if (isSequenceError) {
                            // Handle sequence errors with new table format
                            const sequenceGroups = new Map();
                            
                            errorGroup.rows.forEach(rowError => {
                                if (!rowError.file_level) {
                                    const sequence = parseErrorSequence(rowError.cell_data);
                                    if (sequence) {
                                        const key = `${sequence.errorCode}_${sequence.destinationICAO}_${sequence.originICAO}`;
                                        if (!sequenceGroups.has(key)) {
                                            sequenceGroups.set(key, {
                                                sequence,
                                                rows: []
                                            });
                                        }
                                        
                                        sequenceGroups.get(key).rows.push({
                                            rowError: {
                                                ...rowError,
                                                highlight: false,
                                                editableColumns: rowError.columns.flat()
                                            },
                                            rowData: errorData.rows_data[rowError.row_idx] || {}
                                        });
                                    }
                                }
                            });
                            
                            sequenceGroups.forEach((group, key) => {
                                group.rows.sort((a, b) => a.rowError.row_idx - b.rowError.row_idx);
                                
                                if (group.rows.length === 4) {
                                    group.rows[1].rowError.highlight = true;
                                    group.rows[2].rowError.highlight = true;
                                }
                                
                                const sequenceTable = createSequenceTable(group.sequence, group.rows);
                                content.appendChild(sequenceTable);
                            });
                        } else {
                            // Handle non-sequence errors with original format
                            const reasonDiv = document.createElement('div');
                            reasonDiv.className = 'reason-group';
                            const reasonHeader = document.createElement('div');
                            reasonHeader.className = 'reason-header';
                            
                            const reasonName = document.createElement('div');
                            reasonName.className = 'reason-name';
                            reasonName.textContent = errorGroup.reason;
                            
                            const reasonInfo = document.createElement('div');
                            reasonInfo.style.display = 'flex';
                            reasonInfo.style.alignItems = 'center';
                            
                            const reasonCount = document.createElement('div');
                            reasonCount.className = 'reason-count';
                            reasonCount.textContent = `${errorGroup.rows.length} rows`;
                            
                            const downloadBtn = document.createElement('button');
                            downloadBtn.className = 'download-csv-btn';
                            downloadBtn.title = 'Download Reason Group as CSV';
                            downloadBtn.innerHTML = `
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                    <polyline points="7,10 12,15 17,10"/>
                                    <line x1="12" y1="15" x2="12" y2="3"/>
                                </svg>
                            `;
                            downloadBtn.onclick = (e) => {
                                e.stopPropagation();
                                const reasonIndex = category.errors.indexOf(errorGroup);
                                downloadReasonGroupCSV(catIndex, reasonIndex);
                            };
                            
                            reasonInfo.appendChild(reasonCount);
                            reasonInfo.appendChild(downloadBtn);
                            
                            reasonHeader.appendChild(reasonName);
                            reasonHeader.appendChild(reasonInfo);
                            reasonHeader.onclick = () => toggleReason(reasonHeader.nextElementSibling);
                            const reasonContent = document.createElement('div');
                            reasonContent.className = 'reason-content';
                            // Use batching for performance
                            renderErrorRowsInBatches(errorGroup, reasonContent, 100);
                            reasonDiv.appendChild(reasonHeader);
                            reasonDiv.appendChild(reasonContent);
                            content.appendChild(reasonDiv);
                        }
                    });
                    
                    categoryDiv.appendChild(header);
                    categoryDiv.appendChild(content);
                    container.appendChild(categoryDiv);
                });
                
                // Show error section
                errorSection.style.display = 'block';
                successSection.style.display = 'none';
                
                // Open first category by default
                if (errorData.categories.length > 0) {
                    toggleCategory(0);
                }
                
            } catch (error) {
                console.error('Error in displayErrors:', error);
                console.error('Error stack:', error.stack);
                showAlert('Failed to display errors: ' + error.message, 'error');
            }
        }

        function toggleCategory(index) {
            const content = document.getElementById(`category-content-${index}`);
            if (content) {
                content.style.display = content.style.display === 'none' ? 'block' : 'none';
            }
        }

        function toggleReason(content) {
            if (content) {
                content.style.display = content.style.display === 'none' ? 'block' : 'none';
            }
        }

        // Save corrections
        async function saveCorrections() {
            if (Object.keys(editedCells).length === 0) {
                showAlert('No corrections to save', 'info');
                return;
            }
            
            showLoading('Saving corrections and re-validating...');
            
            const corrections = Object.values(editedCells);
            
            try {
                const response = await fetch(`/upload/${currentFileId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ corrections: corrections })
                });
                
                if (!response.ok) throw new Error('Failed to save corrections');
                
                // Clear edited cells
                editedCells = {};
                
                // Fetch new errors
                await fetchErrors();
                
            } catch (error) {
                showAlert('Failed to save corrections: ' + error.message, 'error');
                hideLoading();
            }
        }

        // Ignore errors
        async function ignoreErrors() {
            if (!confirm('Are you sure you want to ignore remaining errors and proceed to report generation?')) {
                return;
            }
            
            try {
                const response = await fetch(`/upload/${currentFileId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ ignore_errors: true })
                });
                
                if (!response.ok) throw new Error('Failed to process request');
                
                showSuccess();
                
            } catch (error) {
                showAlert('Failed to process request: ' + error.message, 'error');
            }
        }

        // Open chat session with current file data
        async function openChatSession() {
            console.log('🚀 [DEBUG] Button Click → openChatSession() triggered');
            console.log('🚀 [DEBUG] Current file ID:', currentFileId);
            
            if (!currentFileId) {
                console.log('❌ [DEBUG] No file loaded, cannot proceed');
                showAlert('No file loaded. Please upload a file first.', 'error');
                return;
            }
            
            try {
                console.log('📡 [DEBUG] Backend Call → Sending request to /open-chat/' + currentFileId);
                
                // Show loading alert instead of loading section to keep errors visible
                showAlert('Initializing AI chat session...', 'info');
                
                // Disable the chat button to prevent multiple clicks
                const chatButton = document.getElementById('chatButton');
                const originalText = chatButton.innerHTML;
                chatButton.disabled = true;
                chatButton.innerHTML = '<span class="btn-icon">⏳</span> Creating Chat Session...';
                
                // Create chat session from current file
                const response = await fetch(`/open-chat/${currentFileId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                console.log('📡 [DEBUG] Backend Call → Response status:', response.status);
                
                if (!response.ok) {
                    const errorData = await response.json();
                    console.log('❌ [DEBUG] Backend Call → Error response:', errorData);
                    throw new Error(errorData.error || 'Failed to initialize chat session');
                }
                
                const data = await response.json();
                console.log('✅ [DEBUG] Backend Call → Success response:', data);
                console.log('🎯 [DEBUG] Session Creation → Session ID created:', data.session_id);
                
                // Open chat interface in new tab/window
                const chatUrl = `/chat?session_id=${data.session_id}`;
                console.log('🌐 [DEBUG] Chat Redirect → Opening URL:', chatUrl);
                
                // Try multiple methods to open the chat window
                let chatOpened = false;
                
                // Method 1: Try window.open with more permissive settings
                try {
                    const chatWindow = window.open(chatUrl, '_blank', 'menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes,width=1200,height=800');
                    if (chatWindow && !chatWindow.closed) {
                        console.log('🚪 [DEBUG] Chat Redirect → Chat opened in new window');
                        chatWindow.opener = null; // Security: prevent access to parent window
                        chatWindow.focus(); // Ensure the window gets focus
                        chatOpened = true;
                        showAlert('Chat session opened in new window. You can now ask questions about your flight data!', 'success');
                    }
                } catch (popupError) {
                    console.log('🚫 [DEBUG] Chat Redirect → Popup method failed:', popupError);
                }
                
                // Method 2: If popup failed, try opening in same tab with confirmation
                if (!chatOpened) {
                    console.log('🚪 [DEBUG] Chat Redirect → Popup blocked, offering alternative');
                    const userChoice = confirm(
                        'Popup was blocked by your browser.\n\n' +
                        'Click OK to open chat in current tab (you can return using browser back button)\n' +
                        'Click Cancel to get a link you can manually open'
                    );
                    
                    if (userChoice) {
                        console.log('🌐 [DEBUG] Chat Redirect → User chose to navigate in current tab');
                        window.location.href = chatUrl;
                    } else {
                        console.log('📋 [DEBUG] Chat Redirect → Providing manual link');
                        showAlert(`Chat session created! Manually open this link in a new tab: ${window.location.origin}${chatUrl}`, 'info');
                        
                        // Also try to copy to clipboard if possible
                        try {
                            navigator.clipboard.writeText(`${window.location.origin}${chatUrl}`);
                            showAlert('Chat link copied to clipboard! Open it in a new tab.', 'success');
                        } catch (clipboardError) {
                            console.log('📋 [DEBUG] Could not copy to clipboard:', clipboardError);
                        }
                    }
                }
                
                // Re-enable the chat button
                chatButton.disabled = false;
                chatButton.innerHTML = originalText;
                
            } catch (error) {
                console.error('💥 [DEBUG] Chat session error:', error);
                showAlert('Failed to open chat session: ' + error.message, 'error');
                
                // Re-enable the chat button
                const chatButton = document.getElementById('chatButton');
                if (chatButton) {
                    chatButton.disabled = false;
                    chatButton.innerHTML = '<span class="btn-icon">💬</span> Analyze Data with AI Chat';
                }
            }
        }

        // Download clean CSV
        async function downloadCleanCSV() {
            if (!currentFileId) {
                showAlert('No file loaded', 'error');
                return;
            }
            
            try {
                const response = await fetch(`/download/${currentFileId}/clean`);
                
                if (!response.ok) {
                    throw new Error('Failed to download clean CSV');
                }
                
                // Download the file
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'clean_data.csv';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                a.remove();
                
                showAlert('Clean CSV downloaded successfully!', 'success');
                
            } catch (error) {
                showAlert('Failed to download clean CSV: ' + error.message, 'error');
            }
        }

        // Download errors CSV
        async function downloadErrorsCSV() {
            if (!currentFileId) {
                showAlert('No file loaded', 'error');
                return;
            }
            
            try {
                const response = await fetch(`/download/${currentFileId}/errors`);
                
                if (!response.ok) {
                    throw new Error('Failed to download errors CSV');
                }
                
                // Download the file
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'errors_data.csv';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                a.remove();
                
                showAlert('Errors CSV downloaded successfully!', 'success');
                
            } catch (error) {
                showAlert('Failed to download errors CSV: ' + error.message, 'error');
            }
        }

        // Generate report
        async function generateReport() {
            showLoading('Generating CORSIA report...');
            
            try {
                const response = await fetch(`/report/${currentFileId}`, {
                    method: 'POST'
                });
                
                if (!response.ok) throw new Error('Failed to generate report');
                
                // Download the file
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'template_filled.xlsx';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                a.remove();
                
                hideLoading();
                showAlert('Report generated successfully!', 'success');
                
                // Reset after a delay
                setTimeout(resetUpload, 3000);
                
            } catch (error) {
                showAlert('Failed to generate report: ' + error.message, 'error');
                hideLoading();
            }
        }

        // Re-validate
        async function revalidate() {
            showLoading('Re-validating CSV file...');
            
            try {
                const response = await fetch(`/upload/${currentFileId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ revalidate: true })
                });
                
                if (!response.ok) throw new Error('Failed to re-validate');
                
                await fetchErrors();
                
            } catch (error) {
                showAlert('Failed to re-validate: ' + error.message, 'error');
                hideLoading();
            }
        }

        // UI Helper functions
        function showLoading(message) {
            console.log('Showing loading:', message);
            loadingSection.style.display = 'block';
            document.getElementById('loadingMessage').textContent = message;
            uploadSection.style.display = 'none';
            parametersSection.style.display = 'none';
            errorSection.style.display = 'none';
            successSection.style.display = 'none';
        }

        function hideLoading() {
            console.log('Hiding loading');
            loadingSection.style.display = 'none';
        }

        function showSuccess() {
            console.log('Showing success');
            successSection.style.display = 'block';
            errorSection.style.display = 'none';
            loadingSection.style.display = 'none';
        }

        function showAlert(message, type = 'info') {
            console.log('Showing alert:', message, 'Type:', type);
            alertMessage.textContent = message;
            alertMessage.className = `alert alert-${type}`;
            alertMessage.style.display = 'block';
            
            // Hide alert after 5 seconds
            setTimeout(() => {
                alertMessage.style.display = 'none';
            }, 5000);
        }

        function updateProgress(percent) {
            document.getElementById('progressFill').style.width = percent + '%';
        }

        function resetUpload() {
            currentFileId = null;
            currentChunk = 1;
            errorData = null;
            editedCells = {};
            sequenceErrors.clear(); // NEW: Clear sequence errors
            fileInput.value = '';
            fileInfo.textContent = '';

            // Reset mapping variables
            uploadedColumns = [];
            columnMapping = [];
            currentMappingIndex = 0;
            selectedColumnForCurrentStep = null;
            currentFile = null;

            // NEW: Remove final sequence summary if it exists
            const finalSummary = document.getElementById('finalSequenceSummary');
            if (finalSummary) {
                finalSummary.remove();
            }

            hideAllSections();
            uploadSection.style.display = 'block';
        }

        function hideAllSections() {
            uploadSection.style.display = 'none';
            mappingSection.style.display = 'none';
            parametersSection.style.display = 'none';
            loadingSection.style.display = 'none';
            errorSection.style.display = 'none';
            successSection.style.display = 'none';
        }

        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }

        function handleCorrection(event) {
            const input = event.target;
            const row = input.dataset.row;
            const column = input.dataset.column;
            const newValue = input.value;
            
            console.log('Handling correction:', { row, column, newValue });
            
            // Store the correction
            const key = `${row}-${column}`;
            if (newValue !== '') {
                editedCells[key] = {
                    row: parseInt(row),
                    column: column,
                    old_value: this.dataset.originalValue,
                    new_value: this.value
                };
            } else {
                delete editedCells[key];
            }
            
            console.log('Current corrections:', editedCells);
        }
    </script>
</body>
</html>